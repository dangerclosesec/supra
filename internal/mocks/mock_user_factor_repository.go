// Code generated by MockGen. DO NOT EDIT.
// Source: ./user_factor.go
//
// Generated by this command:
//
//	mockgen -typed -source=./user_factor.go -destination=../mocks/mock_user_factor_repository.go -package=mocks UserFactorRepositoryIface
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	model "github.com/dangerclosesec/supra/internal/model"
	repository "github.com/dangerclosesec/supra/internal/repository"
	uuid "github.com/google/uuid"
	gomock "go.uber.org/mock/gomock"
)

// MockUserFactorRepositoryIface is a mock of UserFactorRepositoryIface interface.
type MockUserFactorRepositoryIface struct {
	ctrl     *gomock.Controller
	recorder *MockUserFactorRepositoryIfaceMockRecorder
	isgomock struct{}
}

// MockUserFactorRepositoryIfaceMockRecorder is the mock recorder for MockUserFactorRepositoryIface.
type MockUserFactorRepositoryIfaceMockRecorder struct {
	mock *MockUserFactorRepositoryIface
}

// NewMockUserFactorRepositoryIface creates a new mock instance.
func NewMockUserFactorRepositoryIface(ctrl *gomock.Controller) *MockUserFactorRepositoryIface {
	mock := &MockUserFactorRepositoryIface{ctrl: ctrl}
	mock.recorder = &MockUserFactorRepositoryIfaceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUserFactorRepositoryIface) EXPECT() *MockUserFactorRepositoryIfaceMockRecorder {
	return m.recorder
}

// Begin mocks base method.
func (m *MockUserFactorRepositoryIface) Begin(ctx context.Context) (repository.Transaction, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Begin", ctx)
	ret0, _ := ret[0].(repository.Transaction)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Begin indicates an expected call of Begin.
func (mr *MockUserFactorRepositoryIfaceMockRecorder) Begin(ctx any) *MockUserFactorRepositoryIfaceBeginCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Begin", reflect.TypeOf((*MockUserFactorRepositoryIface)(nil).Begin), ctx)
	return &MockUserFactorRepositoryIfaceBeginCall{Call: call}
}

// MockUserFactorRepositoryIfaceBeginCall wrap *gomock.Call
type MockUserFactorRepositoryIfaceBeginCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUserFactorRepositoryIfaceBeginCall) Return(arg0 repository.Transaction, arg1 error) *MockUserFactorRepositoryIfaceBeginCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUserFactorRepositoryIfaceBeginCall) Do(f func(context.Context) (repository.Transaction, error)) *MockUserFactorRepositoryIfaceBeginCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUserFactorRepositoryIfaceBeginCall) DoAndReturn(f func(context.Context) (repository.Transaction, error)) *MockUserFactorRepositoryIfaceBeginCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Create mocks base method.
func (m *MockUserFactorRepositoryIface) Create(ctx context.Context, factor *model.UserFactor) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Create", ctx, factor)
	ret0, _ := ret[0].(error)
	return ret0
}

// Create indicates an expected call of Create.
func (mr *MockUserFactorRepositoryIfaceMockRecorder) Create(ctx, factor any) *MockUserFactorRepositoryIfaceCreateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockUserFactorRepositoryIface)(nil).Create), ctx, factor)
	return &MockUserFactorRepositoryIfaceCreateCall{Call: call}
}

// MockUserFactorRepositoryIfaceCreateCall wrap *gomock.Call
type MockUserFactorRepositoryIfaceCreateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUserFactorRepositoryIfaceCreateCall) Return(arg0 error) *MockUserFactorRepositoryIfaceCreateCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUserFactorRepositoryIfaceCreateCall) Do(f func(context.Context, *model.UserFactor) error) *MockUserFactorRepositoryIfaceCreateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUserFactorRepositoryIfaceCreateCall) DoAndReturn(f func(context.Context, *model.UserFactor) error) *MockUserFactorRepositoryIfaceCreateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Delete mocks base method.
func (m *MockUserFactorRepositoryIface) Delete(ctx context.Context, factor *model.UserFactor) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Delete", ctx, factor)
	ret0, _ := ret[0].(error)
	return ret0
}

// Delete indicates an expected call of Delete.
func (mr *MockUserFactorRepositoryIfaceMockRecorder) Delete(ctx, factor any) *MockUserFactorRepositoryIfaceDeleteCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockUserFactorRepositoryIface)(nil).Delete), ctx, factor)
	return &MockUserFactorRepositoryIfaceDeleteCall{Call: call}
}

// MockUserFactorRepositoryIfaceDeleteCall wrap *gomock.Call
type MockUserFactorRepositoryIfaceDeleteCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUserFactorRepositoryIfaceDeleteCall) Return(arg0 error) *MockUserFactorRepositoryIfaceDeleteCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUserFactorRepositoryIfaceDeleteCall) Do(f func(context.Context, *model.UserFactor) error) *MockUserFactorRepositoryIfaceDeleteCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUserFactorRepositoryIfaceDeleteCall) DoAndReturn(f func(context.Context, *model.UserFactor) error) *MockUserFactorRepositoryIfaceDeleteCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DeleteByID mocks base method.
func (m *MockUserFactorRepositoryIface) DeleteByID(ctx context.Context, id uuid.UUID) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteByID", ctx, id)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteByID indicates an expected call of DeleteByID.
func (mr *MockUserFactorRepositoryIfaceMockRecorder) DeleteByID(ctx, id any) *MockUserFactorRepositoryIfaceDeleteByIDCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteByID", reflect.TypeOf((*MockUserFactorRepositoryIface)(nil).DeleteByID), ctx, id)
	return &MockUserFactorRepositoryIfaceDeleteByIDCall{Call: call}
}

// MockUserFactorRepositoryIfaceDeleteByIDCall wrap *gomock.Call
type MockUserFactorRepositoryIfaceDeleteByIDCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUserFactorRepositoryIfaceDeleteByIDCall) Return(arg0 error) *MockUserFactorRepositoryIfaceDeleteByIDCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUserFactorRepositoryIfaceDeleteByIDCall) Do(f func(context.Context, uuid.UUID) error) *MockUserFactorRepositoryIfaceDeleteByIDCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUserFactorRepositoryIfaceDeleteByIDCall) DoAndReturn(f func(context.Context, uuid.UUID) error) *MockUserFactorRepositoryIfaceDeleteByIDCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FindActiveByUser mocks base method.
func (m *MockUserFactorRepositoryIface) FindActiveByUser(ctx context.Context, userID uuid.UUID) ([]*model.UserFactor, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindActiveByUser", ctx, userID)
	ret0, _ := ret[0].([]*model.UserFactor)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindActiveByUser indicates an expected call of FindActiveByUser.
func (mr *MockUserFactorRepositoryIfaceMockRecorder) FindActiveByUser(ctx, userID any) *MockUserFactorRepositoryIfaceFindActiveByUserCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindActiveByUser", reflect.TypeOf((*MockUserFactorRepositoryIface)(nil).FindActiveByUser), ctx, userID)
	return &MockUserFactorRepositoryIfaceFindActiveByUserCall{Call: call}
}

// MockUserFactorRepositoryIfaceFindActiveByUserCall wrap *gomock.Call
type MockUserFactorRepositoryIfaceFindActiveByUserCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUserFactorRepositoryIfaceFindActiveByUserCall) Return(arg0 []*model.UserFactor, arg1 error) *MockUserFactorRepositoryIfaceFindActiveByUserCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUserFactorRepositoryIfaceFindActiveByUserCall) Do(f func(context.Context, uuid.UUID) ([]*model.UserFactor, error)) *MockUserFactorRepositoryIfaceFindActiveByUserCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUserFactorRepositoryIfaceFindActiveByUserCall) DoAndReturn(f func(context.Context, uuid.UUID) ([]*model.UserFactor, error)) *MockUserFactorRepositoryIfaceFindActiveByUserCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FindAllByUser mocks base method.
func (m *MockUserFactorRepositoryIface) FindAllByUser(ctx context.Context, userID uuid.UUID) ([]model.UserFactor, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindAllByUser", ctx, userID)
	ret0, _ := ret[0].([]model.UserFactor)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindAllByUser indicates an expected call of FindAllByUser.
func (mr *MockUserFactorRepositoryIfaceMockRecorder) FindAllByUser(ctx, userID any) *MockUserFactorRepositoryIfaceFindAllByUserCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindAllByUser", reflect.TypeOf((*MockUserFactorRepositoryIface)(nil).FindAllByUser), ctx, userID)
	return &MockUserFactorRepositoryIfaceFindAllByUserCall{Call: call}
}

// MockUserFactorRepositoryIfaceFindAllByUserCall wrap *gomock.Call
type MockUserFactorRepositoryIfaceFindAllByUserCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUserFactorRepositoryIfaceFindAllByUserCall) Return(arg0 []model.UserFactor, arg1 error) *MockUserFactorRepositoryIfaceFindAllByUserCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUserFactorRepositoryIfaceFindAllByUserCall) Do(f func(context.Context, uuid.UUID) ([]model.UserFactor, error)) *MockUserFactorRepositoryIfaceFindAllByUserCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUserFactorRepositoryIfaceFindAllByUserCall) DoAndReturn(f func(context.Context, uuid.UUID) ([]model.UserFactor, error)) *MockUserFactorRepositoryIfaceFindAllByUserCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FindByID mocks base method.
func (m *MockUserFactorRepositoryIface) FindByID(ctx context.Context, id uuid.UUID) (*model.UserFactor, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindByID", ctx, id)
	ret0, _ := ret[0].(*model.UserFactor)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindByID indicates an expected call of FindByID.
func (mr *MockUserFactorRepositoryIfaceMockRecorder) FindByID(ctx, id any) *MockUserFactorRepositoryIfaceFindByIDCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindByID", reflect.TypeOf((*MockUserFactorRepositoryIface)(nil).FindByID), ctx, id)
	return &MockUserFactorRepositoryIfaceFindByIDCall{Call: call}
}

// MockUserFactorRepositoryIfaceFindByIDCall wrap *gomock.Call
type MockUserFactorRepositoryIfaceFindByIDCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUserFactorRepositoryIfaceFindByIDCall) Return(arg0 *model.UserFactor, arg1 error) *MockUserFactorRepositoryIfaceFindByIDCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUserFactorRepositoryIfaceFindByIDCall) Do(f func(context.Context, uuid.UUID) (*model.UserFactor, error)) *MockUserFactorRepositoryIfaceFindByIDCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUserFactorRepositoryIfaceFindByIDCall) DoAndReturn(f func(context.Context, uuid.UUID) (*model.UserFactor, error)) *MockUserFactorRepositoryIfaceFindByIDCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FindByUserAndType mocks base method.
func (m *MockUserFactorRepositoryIface) FindByUserAndType(ctx context.Context, userID uuid.UUID, factorType model.FactorType) (*model.UserFactor, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindByUserAndType", ctx, userID, factorType)
	ret0, _ := ret[0].(*model.UserFactor)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindByUserAndType indicates an expected call of FindByUserAndType.
func (mr *MockUserFactorRepositoryIfaceMockRecorder) FindByUserAndType(ctx, userID, factorType any) *MockUserFactorRepositoryIfaceFindByUserAndTypeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindByUserAndType", reflect.TypeOf((*MockUserFactorRepositoryIface)(nil).FindByUserAndType), ctx, userID, factorType)
	return &MockUserFactorRepositoryIfaceFindByUserAndTypeCall{Call: call}
}

// MockUserFactorRepositoryIfaceFindByUserAndTypeCall wrap *gomock.Call
type MockUserFactorRepositoryIfaceFindByUserAndTypeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUserFactorRepositoryIfaceFindByUserAndTypeCall) Return(arg0 *model.UserFactor, arg1 error) *MockUserFactorRepositoryIfaceFindByUserAndTypeCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUserFactorRepositoryIfaceFindByUserAndTypeCall) Do(f func(context.Context, uuid.UUID, model.FactorType) (*model.UserFactor, error)) *MockUserFactorRepositoryIfaceFindByUserAndTypeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUserFactorRepositoryIfaceFindByUserAndTypeCall) DoAndReturn(f func(context.Context, uuid.UUID, model.FactorType) (*model.UserFactor, error)) *MockUserFactorRepositoryIfaceFindByUserAndTypeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FindByUserID mocks base method.
func (m *MockUserFactorRepositoryIface) FindByUserID(ctx context.Context, userID uuid.UUID) ([]model.UserFactor, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindByUserID", ctx, userID)
	ret0, _ := ret[0].([]model.UserFactor)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindByUserID indicates an expected call of FindByUserID.
func (mr *MockUserFactorRepositoryIfaceMockRecorder) FindByUserID(ctx, userID any) *MockUserFactorRepositoryIfaceFindByUserIDCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindByUserID", reflect.TypeOf((*MockUserFactorRepositoryIface)(nil).FindByUserID), ctx, userID)
	return &MockUserFactorRepositoryIfaceFindByUserIDCall{Call: call}
}

// MockUserFactorRepositoryIfaceFindByUserIDCall wrap *gomock.Call
type MockUserFactorRepositoryIfaceFindByUserIDCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUserFactorRepositoryIfaceFindByUserIDCall) Return(arg0 []model.UserFactor, arg1 error) *MockUserFactorRepositoryIfaceFindByUserIDCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUserFactorRepositoryIfaceFindByUserIDCall) Do(f func(context.Context, uuid.UUID) ([]model.UserFactor, error)) *MockUserFactorRepositoryIfaceFindByUserIDCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUserFactorRepositoryIfaceFindByUserIDCall) DoAndReturn(f func(context.Context, uuid.UUID) ([]model.UserFactor, error)) *MockUserFactorRepositoryIfaceFindByUserIDCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ListByUser mocks base method.
func (m *MockUserFactorRepositoryIface) ListByUser(ctx context.Context, userID uuid.UUID) ([]model.UserFactor, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListByUser", ctx, userID)
	ret0, _ := ret[0].([]model.UserFactor)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListByUser indicates an expected call of ListByUser.
func (mr *MockUserFactorRepositoryIfaceMockRecorder) ListByUser(ctx, userID any) *MockUserFactorRepositoryIfaceListByUserCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListByUser", reflect.TypeOf((*MockUserFactorRepositoryIface)(nil).ListByUser), ctx, userID)
	return &MockUserFactorRepositoryIfaceListByUserCall{Call: call}
}

// MockUserFactorRepositoryIfaceListByUserCall wrap *gomock.Call
type MockUserFactorRepositoryIfaceListByUserCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUserFactorRepositoryIfaceListByUserCall) Return(arg0 []model.UserFactor, arg1 error) *MockUserFactorRepositoryIfaceListByUserCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUserFactorRepositoryIfaceListByUserCall) Do(f func(context.Context, uuid.UUID) ([]model.UserFactor, error)) *MockUserFactorRepositoryIfaceListByUserCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUserFactorRepositoryIfaceListByUserCall) DoAndReturn(f func(context.Context, uuid.UUID) ([]model.UserFactor, error)) *MockUserFactorRepositoryIfaceListByUserCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RemoveFactor mocks base method.
func (m *MockUserFactorRepositoryIface) RemoveFactor(ctx context.Context, userID, factorID uuid.UUID) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RemoveFactor", ctx, userID, factorID)
	ret0, _ := ret[0].(error)
	return ret0
}

// RemoveFactor indicates an expected call of RemoveFactor.
func (mr *MockUserFactorRepositoryIfaceMockRecorder) RemoveFactor(ctx, userID, factorID any) *MockUserFactorRepositoryIfaceRemoveFactorCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveFactor", reflect.TypeOf((*MockUserFactorRepositoryIface)(nil).RemoveFactor), ctx, userID, factorID)
	return &MockUserFactorRepositoryIfaceRemoveFactorCall{Call: call}
}

// MockUserFactorRepositoryIfaceRemoveFactorCall wrap *gomock.Call
type MockUserFactorRepositoryIfaceRemoveFactorCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUserFactorRepositoryIfaceRemoveFactorCall) Return(arg0 error) *MockUserFactorRepositoryIfaceRemoveFactorCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUserFactorRepositoryIfaceRemoveFactorCall) Do(f func(context.Context, uuid.UUID, uuid.UUID) error) *MockUserFactorRepositoryIfaceRemoveFactorCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUserFactorRepositoryIfaceRemoveFactorCall) DoAndReturn(f func(context.Context, uuid.UUID, uuid.UUID) error) *MockUserFactorRepositoryIfaceRemoveFactorCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Update mocks base method.
func (m *MockUserFactorRepositoryIface) Update(ctx context.Context, factor *model.UserFactor) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Update", ctx, factor)
	ret0, _ := ret[0].(error)
	return ret0
}

// Update indicates an expected call of Update.
func (mr *MockUserFactorRepositoryIfaceMockRecorder) Update(ctx, factor any) *MockUserFactorRepositoryIfaceUpdateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockUserFactorRepositoryIface)(nil).Update), ctx, factor)
	return &MockUserFactorRepositoryIfaceUpdateCall{Call: call}
}

// MockUserFactorRepositoryIfaceUpdateCall wrap *gomock.Call
type MockUserFactorRepositoryIfaceUpdateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUserFactorRepositoryIfaceUpdateCall) Return(arg0 error) *MockUserFactorRepositoryIfaceUpdateCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUserFactorRepositoryIfaceUpdateCall) Do(f func(context.Context, *model.UserFactor) error) *MockUserFactorRepositoryIfaceUpdateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUserFactorRepositoryIfaceUpdateCall) DoAndReturn(f func(context.Context, *model.UserFactor) error) *MockUserFactorRepositoryIfaceUpdateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
